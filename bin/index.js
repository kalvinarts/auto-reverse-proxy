const { constants } = require('crypto');

const Docker =  require('dockerode');
const Redbird = require('redbird');

const { Manager } = require('../index');

const {
  ARP_CERTS_PATH,
  ARP_SOCKET_PATH,
  ARP_NETWORK_NAME,
} = process.env;

const argv = require('yargs')
  .scriptName('reverse-proxy')
  .option('certsPath', {
    alias: 'c',
    demandOption: true,
    default: ARP_CERTS_PATH || '/tmp/certs',
    describe: 'Path to store the autogenerated certifiactes',
    type: 'string',
  })
  .option('socketPath', {
    alias: 's',
    demandOption: true,
    default: ARP_SOCKET_PATH || '/var/run/docker.sock',
    describe: 'Path of the docker unix socket',
    type: 'string',
  })
  .option('networkName', {
    alias: 'n',
    demandOption: true,
    default: ARP_NETWORK_NAME || 'bridge',
    describe: 'Network to monitor for containers to register',
    type: 'string',
  })
  .argv;

const docker = new Docker({
  socketPath: argv.socketPath,
});

const redbird = Redbird({
  port: 80,
  xfwd: true, // http port is needed for LetsEncrypt challenge during request / renewal. Also enables automatic http->https redirection for registered https routes.
  letsencrypt: {
    path: argv.certsPath,
    port: 9999, // redbird gets your certificates throug this port
  },
  ssl: {
    http2: true,
    port: 443, // SSL port used to serve registered https routes with LetsEncrypt certificate.
    secureOptions: constants.SSL_OP_NO_TLSv1,
  },
  bunyan: false, // Disable bunyan
});

const manager = new Manager({
  redbird,
  docker,
  networkName: argv.networkName,
  debugMode: true,
});

manager.start();
